/*
 *
 * This is a port of
 * https://github.com/gkdr/lurch/blob/master/src/lurch.c
 *
 * Concept is to stay as much as possible at the original functions to make change tracking easier
 *
 */

#include "Omemo.h"
#include "System.h"

#include <gcrypt.h>
#include <mxml.h>

#include <QDir>
#include <QDomDocument>
#include <QTimer>

#include <QDebug>

// see https://www.ietf.org/rfc/rfc3920.txt
#define JABBER_MAX_LEN_NODE 1023
#define JABBER_MAX_LEN_DOMAIN 1023
#define JABBER_MAX_LEN_BARE JABBER_MAX_LEN_NODE + JABBER_MAX_LEN_DOMAIN + 1

#define LURCH_DB_SUFFIX "_db.sqlite"
#define LURCH_DB_NAME_OMEMO "omemo"
#define LURCH_DB_NAME_AXC "axc"

#define LURCH_ERR           -1000000
#define LURCH_ERR_NOMEM     -1000001
#define LURCH_ERR_NO_BUNDLE -1000010

// key: char * (name of muc), value: GHashTable * (mapping of user alias to full jid)
GHashTable * chat_users_ht_p = nullptr;


Omemo::Omemo(QObject *parent) : QObject(parent),
    client_(NULL), actualBareJid_(""), uninstall(0)
{
    // create omemo path if needed
    QString omemoLocation = System::getOmemoPath();
    QDir dir(omemoLocation);

    if (!dir.exists()) {
        dir.mkpath(".");
    }

    // init omemo crypto
    omemo_default_crypto_init();
}

Omemo::~Omemo()
{
    omemo_default_crypto_teardown();
}

void Omemo::setupWithClient(Swift::Client *client)
{
    if (client != NULL)
    {
        client_ = client;

        // FIXME connect msg send, msg receive, pep device list update
        client_->onMessageReceived.connect(boost::bind(&Omemo::handleMessageReceived, this, _1));
        client_->onDataRead.connect(boost::bind(&Omemo::handleDataReceived, this, _1));

        // FIXME for device list updates
        // lurch_pep_devicelist_event_handler

        // FIXME catches to be sent messages and encrypts
        //lurch_xml_sent_cb => lurch_message_encrypt_im || lurch_message_encrypt_groupchat

        // FIXME handles presence and message decryption
        // lurch_xml_received_cb

        // request own device list
        // similar to lurch_account_connect_cb()
        requestDeviceList(client_->getJID().toBare());

        //QTimer::singleShot(5000, this, SLOT(sendEncMsg()));
    }
}

void Omemo::sendEncMsg()
{
    //qDebug() << "requst device list for sjde ";
    //requestDeviceList(Swift::JID("schorsch@jabber-germany.de"));
    //qDebug() << "try to send enc ";
    //lurch_message_encrypt_im("schorsch@jabber-germany.de", "enc omemo msg1");
    //lurch_message_encrypt_im("schorsch@jabber-germany.de", "enc omemo msg2");
}

void Omemo::requestDeviceList(const Swift::JID& jid)
{
    char * dl_ns = (char *) 0;

    int ret_val = omemo_devicelist_get_pep_node_name(&dl_ns);
    if (ret_val)
    {
        qDebug() << "failed to get devicelist pep node name";
    }
    else
    {
        actualBareJid_ = jid.toBare();

        // gen the payload
        const std::string deviceListRequestXml = "<pubsub xmlns='http://jabber.org/protocol/pubsub'><items node='" + std::string(dl_ns) + "'/></pubsub>";

        Swift::RawRequest::ref requestDeviceList = Swift::RawRequest::create(Swift::IQ::Get, jid.toBare(), deviceListRequestXml, client_->getIQRouter());
        requestDeviceList->onResponse.connect(boost::bind(&Omemo::handleDeviceListResponse, this, _1));

        requestDeviceList->send();

        free(dl_ns);
    }
}

void Omemo::handleDeviceListResponse(const std::string& str)
{
    qDebug() << "OMEMO: handle device list Response: " << QString::fromStdString(str);

    // handle own device list
    if (actualBareJid_.toString() == client_->getJID().toBare().toString())
    {
        lurch_pep_own_devicelist_request_handler(str);
    }
    else
    {
        // FIXME hard coded!
        QString strippedXml = getItemsChildFromPubSubXml(QString::fromStdString(str));
        QByteArray xmlArray = strippedXml.toLocal8Bit();
        char* strippedXmlCStr = xmlArray.data();

        qDebug() << "new device list " << strippedXml << " for sjd!";

        lurch_pep_devicelist_event_handler("schorsch@jabber-germany.de", strippedXmlCStr);
    }
}


/**
 * A JabberPEPHandler function.
 * On receiving a devicelist PEP update it updated the database.
 */
void Omemo::lurch_pep_devicelist_event_handler(const char * from, const std::string &items_p) {
    int ret_val = 0;
    //int len = 0;
    char * err_msg_dbg = nullptr;

    //char * uname = (void *) 0;
    std::string bareJid = client_->getJID().toBare().toString();
    QByteArray JidArray = QString::fromStdString(bareJid).toLocal8Bit();
    char* uname = JidArray.data();

    omemo_devicelist * dl_in_p = nullptr;

    if (!strncmp(uname, from, strnlen(uname, JABBER_MAX_LEN_BARE))) {
        //own devicelist is dealt with in own handler
        lurch_pep_own_devicelist_request_handler(items_p);
        goto cleanup;
    }

    purple_debug_info("lurch", "%s: %s received devicelist update from %s\n", __func__, uname, from);

    // FIXME const_cast
    ret_val = omemo_devicelist_import(const_cast<char*>(items_p.c_str()), from, &dl_in_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to import devicelist");
        goto cleanup;
    }

    ret_val = lurch_devicelist_process(uname, dl_in_p);
    if(ret_val) {
        err_msg_dbg = g_strdup_printf("failed to process devicelist");
        goto cleanup;
    }

cleanup:
    if (err_msg_dbg) {
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        g_free(err_msg_dbg);
    }
    //g_free(uname);
    omemo_devicelist_destroy(dl_in_p);
}


void Omemo::requestBundle(unsigned int device_id, const Swift::JID& jid)
{
    /*
     * <iq type='get' from='romeo@montague.lit' to='juliet@capulet.lit' id='fetch1'>
          <pubsub xmlns='http://jabber.org/protocol/pubsub'>
            <items node='eu.siacs.conversations.axolotl.bundles:31415 max_items='1'/>
          </pubsub>
       </iq>
     */

    char * bundle_node_name = nullptr;

    int ret_val = omemo_bundle_get_pep_node_name(device_id, &bundle_node_name);
    if (ret_val)
    {
        qDebug() << "failed to get bundle pep node name for" << QString::fromStdString(jid.toString());
    }
    else
    {
        actualBareJid_ = jid.toBare();

        // gen the payload
        const std::string bundleRequestXml = "<pubsub xmlns='http://jabber.org/protocol/pubsub'><items node='" + std::string(bundle_node_name) + "' max_items='1' /></pubsub>";

        Swift::RawRequest::ref requestBundle = Swift::RawRequest::create(Swift::IQ::Get, jid.toBare(), bundleRequestXml, client_->getIQRouter());
        requestBundle->onResponse.connect(boost::bind(&Omemo::handleBundleResponse, this, _1));

        requestBundle->send();

        g_free(bundle_node_name);
    }
}

void Omemo::handleBundleResponse(const std::string& str)
{
    std::cout << "OMEMO: handle bundle Response: " << str;
    // FIXME
    // implement lurch_bundle_request_cb
}


void Omemo::publishPepRawXml(const Swift::JID& jid, const QString& rawXml)
{
    // gen the payload
    const std::string pubsubXml = "<pubsub xmlns='http://jabber.org/protocol/pubsub'>" + rawXml.toStdString() + "</pubsub>";

    Swift::RawRequest::ref publishPep = Swift::RawRequest::create(Swift::IQ::Set,
                                                                            jid.toBare(),
                                                                            pubsubXml,
                                                                            client_->getIQRouter());
    // FIXME create responder to catch the errors
    //requestDeviceList->onResponse.connect(boost::bind(&Omemo::handleDeviceListResponse, this, _1));

    publishPep->send();
}

void Omemo::handleDataReceived(Swift::SafeByteArray data)
{
    std::string nodeData = Swift::safeByteArrayToString(data);
    QString qData = QString::fromStdString(nodeData);

    qDebug() << "####### received: " << qData;

    if (isEncryptedMessage(qData))
    {
        QString from = getValueForElementInMessage(qData, "from");
        QString type = getValueForElementInMessage(qData, "type");

        if ( (! from.isEmpty()) && (! type.isEmpty()) )
        {
            lurch_message_decrypt(from.toStdString().c_str(), type.toStdString().c_str(), nodeData);
        }
    }

    /*
     * <message to='schorsch@jabber.ccc.de/shmoose' from='schorsch@jabber-germany.de/phone' type='chat' id='1a90006a-1b6b-475f-9948-fc3c4f68af28'><archived by='schorsch@jabber.ccc.de' id='1516908776256391' xmlns='urn:xmpp:mam:tmp'/><stanza-id by='schorsch@jabber.ccc.de' id='1516908776256391' xmlns='urn:xmpp:sid:0'/><encrypted xmlns='eu.siacs.conversations.axolotl'><header sid='1159222349'><key prekey='true' rid='1957814484'>MwhkEiEFjlXWOlbgc9aiQxOkLccALc2RlffG3kvDt0dTGx3gZzMaIQWEUcL07z/YZWCMpANTMI5pR9HdToso6vDMYCIa+Y2CQiJiMwohBaEsRPqOAtgzhKoBMsImvhDBVOYHYRrk9DpKEur8s1kXEAEYACIwyEF6DO6RJ24Fus3r3zTIAr1Lao4AjhRVrOiGpBJ5bJcM2qt7Ev39R6GCNDAOowbQ46XXUlSM5loozajhqAQwAA==</key><key prekey='true' rid='1164523883'>MwgzEiEFQJYGeNhXgnQ8AFRrejAoxffnowzuOVBqOvMId0VTqGcaIQWEUcL07z/YZWCMpANTMI5pR9HdToso6vDMYCIa+Y2CQiJiMwohBbrRD7+bTklgVqp74Ncwk8HwFfU3EE3+xIL5IYWdOAUOEAEYACIwjhYG7eHEJjhgUYzgXvVJaIkI0Zt9tqwidswaQM2lgEFDlU4AOCCOktv5jTCRlnJ91tFkM/OBw68ozajhqAQwAQ==</key><iv>gLoMLZqrZ2TDSVHPjq1olw==</iv></header><payload>pw==</payload></encrypted><markable xmlns='urn:xmpp:chat-markers:0'/><request xmlns='urn:xmpp:receipts'/><origin-id xmlns='urn:xmpp:sid:0' id='1a90006a-1b6b-475f-9948-fc3c4f68af28'/><store xmlns='urn:xmpp:hints'/><encryption xmlns='urn:xmpp:eme:0' namespace='eu.siacs.conversations.axolotl' name='OMEMO'/><body>I sent you an OMEMO encrypted message but your client doesnâ€™t seem to support that. Find more information on https://conversations.im/omemo</body></message>
     */
}

void Omemo::handleMessageReceived(Swift::Message::ref message)
{
    std::cout << "OMEMO: handleMessageReceived: jid: " << message->getFrom() << ", bare: " << message->getFrom().toBare().toString() << ", resource: " << message->getFrom().getResource() << std::endl;
}


/**
 * Callback for the "receiving xmlnode" signal.
 * Decrypts message, if applicable.
 */
void Omemo::lurch_message_decrypt(const char* from, const char* type, std::string msg_stanza_pp) {
    int ret_val = 0;
    char * err_msg_dbg = nullptr;
    int len;

    omemo_message * msg_p = nullptr;
    char * uname = nullptr;
    char * db_fn_omemo = nullptr;
    axc_context * axc_ctx_p = nullptr;
    uint32_t own_id = 0;
    uint8_t * key_p = nullptr;
    size_t key_len = 0;
    axc_buf * key_buf_p = nullptr;
    axc_buf * key_decrypted_p = nullptr;
    char * sender_name = nullptr;
    axc_address sender_addr = {0};
    char * bundle_node_name = nullptr;
    omemo_message * keytransport_msg_p = nullptr;
    char * xml = nullptr;
    char * sender = nullptr;
    char ** split = nullptr;
    char * room_name = nullptr;
    char * buddy_nick = nullptr;
    GHashTable * nick_jid_ht_p = nullptr;
    //xmlnode * plaintext_msg_node_p = nullptr;
    char * recipient_bare_jid = nullptr;
    //PurpleConversation * conv_p = nullptr;

//    const char * type = xmlnode_get_attrib(*msg_stanza_pp, "type");
//    const char * from = xmlnode_get_attrib(*msg_stanza_pp, "from");

    std::string bareJid = client_->getJID().toBare().toString();
    QByteArray JidArray = QString::fromStdString(bareJid).toLocal8Bit();

    if (uninstall) {
        goto cleanup;
    }

    //uname = lurch_uname_strip(purple_account_get_username(purple_connection_get_account(gc_p)));
    uname = JidArray.data();

    db_fn_omemo = lurch_uname_get_db_fn(uname, LURCH_DB_NAME_OMEMO);

    if (!g_strcmp0(type, "chat")) {
        // FIXME const_cast!!!
        sender = const_cast<char*>(Swift::JID(from).toBare().toString().c_str());
        //sender = jabber_get_bare_jid(from);

        ret_val = omemo_storage_chatlist_exists(sender, db_fn_omemo);
        if (ret_val < 0) {
            err_msg_dbg = g_strdup_printf("failed to look up %s in %s", sender, db_fn_omemo);
            goto cleanup;
        } else if (ret_val == 1) {
            // FIXME
            //purple_conv_present_error(sender, purple_connection_get_account(gc_p), "Received encrypted message in blacklisted conversation.");
            qDebug() << "Received encrypted message in blacklisted conversation.";
        }
    } else if (!g_strcmp0(type, "groupchat")) {
        // FIXME groupchat encryption
        qDebug() << "FIXME groupchat encryption";
#if 0
        split = g_strsplit(from, "/", 2);
        room_name = split[0];
        buddy_nick = split[1];

        ret_val = omemo_storage_chatlist_exists(room_name, db_fn_omemo);
        if (ret_val < 0) {
            err_msg_dbg = g_strdup_printf("failed to look up %s in %s", room_name, db_fn_omemo);
            goto cleanup;
        } else if (ret_val == 0) {
            // FIXME
            //purple_conv_present_error(room_name, purple_connection_get_account(gc_p), "Received encrypted message in non-OMEMO room.");
            qDebug() << "eceived encrypted message in non-OMEMO room.";
        }

        nick_jid_ht_p = g_hash_table_lookup(chat_users_ht_p, room_name);
        sender = g_strdup(g_hash_table_lookup(nick_jid_ht_p, buddy_nick));
#endif
    }

    // FIXME const cast
    ret_val = omemo_message_prepare_decryption(const_cast<char*>(msg_stanza_pp.c_str()), &msg_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed import msg for decryption");
        goto cleanup;
    }

    ret_val = lurch_axc_get_init_ctx(uname, &axc_ctx_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to get axc ctx for %s", uname);
        goto cleanup;
    }

    ret_val = axc_get_device_id(axc_ctx_p, &own_id);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to get own device id");
        goto cleanup;
    }

    ret_val = omemo_message_get_encrypted_key(msg_p, own_id, &key_p, &key_len);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to get key for own id %i", own_id);
        goto cleanup;
    }
    if (!key_p) {
        purple_debug_info("lurch", "received omemo message that does not contain a key for this device, skipping\n");
        goto cleanup;
    }

    key_buf_p = axc_buf_create(key_p, key_len);
    if (!key_buf_p) {
        err_msg_dbg = g_strdup_printf("failed to create buf for key");
        goto cleanup;
    }

    sender_addr.name = sender;
    sender_addr.name_len = strnlen(sender_addr.name, JABBER_MAX_LEN_BARE);
    sender_addr.device_id = omemo_message_get_sender_id(msg_p);

    ret_val = axc_pre_key_message_process(key_buf_p, &sender_addr, axc_ctx_p, &key_decrypted_p);
    if (ret_val == AXC_ERR_NOT_A_PREKEY_MSG) {
        if (axc_session_exists_initiated(&sender_addr, axc_ctx_p)) {
            ret_val = axc_message_decrypt_from_serialized(key_buf_p, &sender_addr, axc_ctx_p, &key_decrypted_p);
            if (ret_val) {
                err_msg_dbg = g_strdup_printf("failed to decrypt key");
                goto cleanup;
            }
        } else {
            purple_debug_info("lurch", "received omemo message that does not contain a key for this device, ignoring\n");
            goto cleanup;
        }
    } else if (ret_val == AXC_ERR_INVALID_KEY_ID) {
        ret_val = omemo_bundle_get_pep_node_name(sender_addr.device_id, &bundle_node_name);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to get bundle pep node name");
            goto cleanup;
        }

        // FIXME implement request of keys!
#if 0
        jabber_pep_request_item(purple_connection_get_protocol_data(gc_p),
                                sender_addr.name, bundle_node_name,
                                (void *) 0,
                                lurch_pep_bundle_for_keytransport);
#endif

    } else if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to prekey msg");
        goto cleanup;
    } else {
        lurch_bundle_publish_own(/*purple_connection_get_protocol_data(gc_p)*/);
    }

    if (!omemo_message_has_payload(msg_p)) {
        purple_debug_info("lurch", "received keytransportmsg\n");
        goto cleanup;
    }

    ret_val = omemo_message_export_decrypted(msg_p, axc_buf_get_data(key_decrypted_p), axc_buf_get_len(key_decrypted_p), &crypto_, &xml);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to decrypt payload");
        goto cleanup;
    }

    // FIXME do something with encrypted msg node in xml;
    //plaintext_msg_node_p = xmlnode_from_str(xml, -1);
    qDebug() << "##### dec: " << xml;

    if (g_strcmp0(sender, uname)) {
        // FIXME return plaintext msg
        //*msg_stanza_pp = plaintext_msg_node_p;
    } else {
        qDebug() << "FIXME chat not implemented yet!";
#if 0
        if (!g_strcmp0(type, "chat")) {
            recipient_bare_jid = jabber_get_bare_jid(xmlnode_get_attrib(*msg_stanza_pp, "to"));
            conv_p = purple_find_conversation_with_account(PURPLE_CONV_TYPE_CHAT, sender, purple_connection_get_account(gc_p));
            if (!conv_p) {
                conv_p = purple_conversation_new(PURPLE_CONV_TYPE_IM, purple_connection_get_account(gc_p), recipient_bare_jid);;
            }
            purple_conversation_write(conv_p, uname, xmlnode_get_data(xmlnode_get_child(plaintext_msg_node_p, "body")), PURPLE_MESSAGE_SEND, time((void *) 0));
            *msg_stanza_pp = (void *) 0;
        }
#endif
    }

cleanup:
    if (err_msg_dbg) {
        // FIXME error to user
        //purple_conv_present_error(sender, purple_connection_get_account(gc_p), LURCH_ERR_STRING_DECRYPT);
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
    }

    g_strfreev(split);
    //free(sender); FIXME
    free(xml);
    free(bundle_node_name);
    free(sender_name);
    axc_buf_free(key_decrypted_p);
    axc_buf_free(key_buf_p);
    free(key_p);
    axc_context_destroy_all(axc_ctx_p);
    //free(uname);
    free(db_fn_omemo);
    free(recipient_bare_jid);
    omemo_message_destroy(keytransport_msg_p);
    omemo_message_destroy(msg_p);
}



/**
 * A JabberPEPHandler function.
 * Is used to handle the own devicelist and also perform install-time functions.
 */
void Omemo::lurch_pep_own_devicelist_request_handler(const std::string &items_p) {

#if 0
 char * response = "<pubsub xmlns=\"http://jabber.org/protocol/pubsub\"> \
  <items node=\"eu.siacs.conversations.axolotl.devicelist\"> \
   <item id=\"COFFEEBABE\"> \
    <list xmlns=\"eu.siacs.conversations.axolotl\"> \
     <device id=\"1234567890\"></device> \
    </list> \
   </item> \
  </items> \
 </pubsub>";

         char * strippedXmlCStr = "<items node=\"eu.siacs.conversations.axolotl.devicelist\"> \
           <item id=\"COFFEEBABE\"> \
            <list xmlns=\"eu.siacs.conversations.axolotl\"> \
             <device id=\"1234567890\"></device> \
            </list> \
           </item> \
          </items>";
#endif

         //char * strippedXmlCStr = "<items node=\"eu.siacs.conversations.axolotl.devicelist\"><item id=\"COFFEEBABE\"><list xmlns=\"eu.siacs.conversations.axolotl\"><device id=\"1234567890\"></device></list></item></items>";


    int ret_val = 0;
    char * err_msg_dbg = nullptr;

    int install = 0;
    axc_context * axc_ctx_p = nullptr;
    uint32_t own_id = 0;
    int needs_publishing = 1;
    omemo_devicelist * dl_p = nullptr;
    char * dl_xml = nullptr;

    std::string bareJid = client_->getJID().toBare().toString();
    QByteArray JidArray = QString::fromStdString(bareJid).toLocal8Bit();
    char* uname = JidArray.data();

    //install = (purple_account_get_bool(acc_p, LURCH_ACC_SETTING_INITIALIZED, FALSE)) ? 0 : 1;
    // FIXME
    install = 1; // FIXME set to 0 if already installed

    if (install && !uninstall) {
        purple_debug_info("lurch", "%s: %s\n", __func__, "preparing installation...");
        ret_val = lurch_axc_prepare(uname);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to prepare axc");
            goto cleanup;
        }
        purple_debug_info("lurch", "%s: %s\n", __func__, "...done");
    }

    ret_val = lurch_axc_get_init_ctx(uname, &axc_ctx_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to init axc ctx");
        goto cleanup;
    }
    ret_val = axc_get_device_id(axc_ctx_p, &own_id);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to get own id");
        goto cleanup;
    }

    if (items_p.empty()) { // FIXME this function wont be called on an empty device list
    //if (true) {
        purple_debug_info("lurch", "%s: %s\n", __func__, "no devicelist yet, creating it");
        ret_val = omemo_devicelist_create(uname, &dl_p);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to create devicelist");
            goto cleanup;
        }
        ret_val = omemo_devicelist_add(dl_p, own_id);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to add own id %i to devicelist", own_id);
            goto cleanup;
        }
    } else {
        purple_debug_info("lurch", "%s: %s\n", __func__, "comparing received devicelist with cached one");
        QString strippedXml = getItemsChildFromPubSubXml(QString::fromStdString(items_p));

        QByteArray xmlArray = strippedXml.toLocal8Bit();
        char* strippedXmlCStr = xmlArray.data();

        fprintf(stderr, "items: %s\n", strippedXmlCStr);
#if 0
        mxml_node_t * items_node_p = mxmlLoadString(nullptr, strippedXmlCStr, MXML_NO_CALLBACK);
        if (items_node_p == NULL)
            qDebug() << "items is NULL";
        ret_val = strncmp(mxmlGetElement(items_node_p), "items", strlen("items"));
        qDebug() << "items: " << ret_val;

        mxml_node_t * item_node_p = mxmlGetFirstChild(items_node_p);
        //mxml_node_t * item_node_p = mxmlGetNextSibling(items_node_p);
        if (item_node_p == NULL)
            qDebug() << "item is NULL";
        ret_val = strncmp(mxmlGetElement(item_node_p), "item", strlen("item"));
        qDebug() << "item: " << ret_val;
#endif
        // FIXME crashes in this call
        // no answer from libomemo owner until now
        // TODO improve own fix an make pull request
        ret_val = omemo_devicelist_import(strippedXmlCStr, uname, &dl_p);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to import received devicelist");
            goto cleanup;
        }

        ret_val = omemo_devicelist_contains_id(dl_p, own_id);
        if (ret_val == 1) {
            purple_debug_info("lurch", "%s: %s\n", __func__, "own id was already contained in received devicelist, doing nothing");
            needs_publishing = 0;
        } else if (ret_val == 0) {
            if (!uninstall) {
                purple_debug_info("lurch", "%s: %s\n", __func__, "own id was missing, adding it");
                ret_val = omemo_devicelist_add(dl_p, own_id);
                if (ret_val) {
                    err_msg_dbg = g_strdup_printf("failed to add own id %i to devicelist", own_id);
                    goto cleanup;
                }
            } else {
                needs_publishing = 0;
            }

        } else {
            err_msg_dbg = g_strdup_printf("failed to look up if the devicelist contains the own id");
            goto cleanup;
        }
    }

    if (needs_publishing) {
        purple_debug_info("lurch", "%s: %s\n", __func__, "devicelist needs publishing...");
        ret_val = omemo_devicelist_export(dl_p, &dl_xml);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to export new devicelist");
            goto cleanup;
        }

        publishPepRawXml(client_->getJID(), QString(dl_xml));

        //std::cout << "pubish pep (response own device list): " << dl_xml;
        /*
         * <publish node="eu.siacs.conversations.axolotl.devicelist">
         *   <item>
         *     <list xmlns="eu.siacs.conversations.axolotl">
         *        <device id="1394567069" />
         *     </list>
         *    </item>
         * </publish>
         */

        purple_debug_info("lurch", "%s: \n%s:\n", __func__, "...done");
    }

    ret_val = lurch_bundle_publish_own(/*js_p*/);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to publish own bundle");
        goto cleanup;
    }

    if (install && !uninstall) {
        //purple_account_set_bool(acc_p, LURCH_ACC_SETTING_INITIALIZED, TRUE);
        // FIXME
    }

    ret_val = lurch_devicelist_process(uname, dl_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to process the devicelist");
        goto cleanup;
    }

cleanup:
    if (err_msg_dbg) {
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
    }

    axc_context_destroy_all(axc_ctx_p);
    omemo_devicelist_destroy(dl_p);
    free(dl_xml);
}

/**
 * Does the first-time install of the axc DB.
 * As specified in OMEMO, it checks if the generated device ID already exists.
 * Therefore, it should be called at a point in time when other entries exist.
 *
 * @param uname The username.
 * @return 0 on success, negative on error.
 */
int Omemo::lurch_axc_prepare(char * uname) {
    int ret_val = 0;
    char * err_msg_dbg = nullptr;

    axc_context * axc_ctx_p = nullptr;
    uint32_t device_id = 0;
    char * db_fn_omemo = nullptr;

    ret_val = lurch_axc_get_init_ctx(uname, &axc_ctx_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to get init axc ctx");
        goto cleanup;
    }

    ret_val = axc_get_device_id(axc_ctx_p, &device_id);
    if (!ret_val) {
        // already installed
        goto cleanup;
    }

    db_fn_omemo = lurch_uname_get_db_fn(uname, LURCH_DB_NAME_OMEMO);

    while (1) {
        ret_val = axc_install(axc_ctx_p);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to install axc");
            goto cleanup;
        }

        ret_val = axc_get_device_id(axc_ctx_p, &device_id);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to get own device id");
            goto cleanup;
        }

        ret_val = omemo_storage_global_device_id_exists(device_id, db_fn_omemo);
        if (ret_val == 1)  {
            ret_val = axc_db_init_status_set(AXC_DB_NEEDS_ROLLBACK, axc_ctx_p);
            if (ret_val) {
                err_msg_dbg = g_strdup_printf("failed to set axc db to rollback");
                goto cleanup;
            }
        } else if (ret_val < 0) {
            err_msg_dbg = g_strdup_printf("failed to access the db %s", db_fn_omemo);
            goto cleanup;
        } else {
            break;
        }
    }

cleanup:
    if (err_msg_dbg) {
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
    }
    axc_context_destroy_all(axc_ctx_p);
    free(db_fn_omemo);

    return ret_val;
}


/**
 * Creates and initializes the axc context.
 *
 * @param uname The username.
 * @param ctx_pp Will point to an initialized axc context on success.
 * @return 0 on success, negative on error.
 */
int Omemo::lurch_axc_get_init_ctx(char * uname, axc_context ** ctx_pp) {
    int ret_val = 0;
    char * err_msg_dbg = nullptr;

    axc_context * ctx_p = nullptr;
    char * db_fn = nullptr;

    ret_val = axc_context_create(&ctx_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to create axc context");
        goto cleanup;
    }

    db_fn = lurch_uname_get_db_fn(uname, LURCH_DB_NAME_AXC);
    ret_val = axc_context_set_db_fn(ctx_p, db_fn, strlen(db_fn));
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to set axc db filename");
        goto cleanup;
    }

    ret_val = axc_init(ctx_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to init axc context");
        goto cleanup;
    }

    *ctx_pp = ctx_p;

cleanup:
    if (ret_val) {
        axc_context_destroy_all(ctx_p);
    }
    if (err_msg_dbg) {
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
    }

    free (db_fn);
    return ret_val;
}

/**
 * Returns the db name, has to be g_free()d.
 *
 * @param uname The username.
 * @param which Either LURCH_DB_NAME_OMEMO or LURCH_DB_NAME_AXC
 * @return The path string.
 */
char * Omemo::lurch_uname_get_db_fn(const char * uname, char * which)
{
    std::string omemoPath = System::getOmemoPath().toStdString();
    return g_strconcat(omemoPath.c_str(), "/", uname, "_", which, LURCH_DB_SUFFIX, NULL);
}

/**
 * Collects the information needed for a bundle and publishes it.
 *
 * @param uname The username.
 * @param js_p Pointer to the connection to use for publishing.
 */
int Omemo::lurch_bundle_publish_own(/*JabberStream * js_p*/) {
    int ret_val = 0;
    char * err_msg_dbg = nullptr;

    axc_context * axc_ctx_p = nullptr;
    axc_bundle * axcbundle_p = nullptr;
    omemo_bundle * omemobundle_p = nullptr;
    axc_buf * curr_buf_p = nullptr;
    axc_buf_list_item * next_p = nullptr;
    char * bundle_xml = nullptr;
    //xmlnode * publish_node_bundle_p = nullptr;

    std::string bareJid = client_->getJID().toBare().toString();
    QByteArray barJidArray = QString::fromStdString(bareJid).toLocal8Bit();
    char* uname = barJidArray.data();


    ret_val = lurch_axc_get_init_ctx(uname, &axc_ctx_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to init axc ctx");
        goto cleanup;
    }

    ret_val = axc_bundle_collect(AXC_PRE_KEYS_AMOUNT, axc_ctx_p, &axcbundle_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to collect axc bundle");
        goto cleanup;
    }

    ret_val = omemo_bundle_create(&omemobundle_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to create omemo_bundle");
        goto cleanup;
    }

    ret_val = omemo_bundle_set_device_id(omemobundle_p, axc_bundle_get_reg_id(axcbundle_p));
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to set device id in omemo bundle");
        goto cleanup;
    }

    curr_buf_p = axc_bundle_get_signed_pre_key(axcbundle_p);
    ret_val = omemo_bundle_set_signed_pre_key(omemobundle_p,
                                              axc_bundle_get_signed_pre_key_id(axcbundle_p),
                                              axc_buf_get_data(curr_buf_p),
                                              axc_buf_get_len(curr_buf_p));
    if(ret_val) {
        err_msg_dbg = g_strdup_printf("failed to set signed pre key in omemo bundle");
        goto cleanup;
    }

    curr_buf_p = axc_bundle_get_signature(axcbundle_p);
    ret_val = omemo_bundle_set_signature(omemobundle_p,
                                         axc_buf_get_data(curr_buf_p),
                                         axc_buf_get_len(curr_buf_p));
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to set signature in omemo bundle");
        goto cleanup;
    }

    curr_buf_p = axc_bundle_get_identity_key(axcbundle_p);
    ret_val = omemo_bundle_set_identity_key(omemobundle_p,
                                            axc_buf_get_data(curr_buf_p),
                                            axc_buf_get_len(curr_buf_p));
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to set public identity key in omemo bundle");
        goto cleanup;
    }

    next_p = axc_bundle_get_pre_key_list(axcbundle_p);
    while (next_p) {
        curr_buf_p = axc_buf_list_item_get_buf(next_p);
        ret_val = omemo_bundle_add_pre_key(omemobundle_p,
                                           axc_buf_list_item_get_id(next_p),
                                           axc_buf_get_data(curr_buf_p),
                                           axc_buf_get_len(curr_buf_p));
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to add public pre key to omemo bundle");
            goto cleanup;
        }
        next_p = axc_buf_list_item_get_next(next_p);
    }

    ret_val = omemo_bundle_export(omemobundle_p, &bundle_xml);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to export omemo bundle to xml");
        goto cleanup;
    }

    //publish_node_bundle_p = xmlnode_from_str(bundle_xml, -1);
    //jabber_pep_publish(js_p, publish_node_bundle_p);
    //std::cout << "publish pep (bundle): " << bundle_xml;

    publishPepRawXml(client_->getJID(), QString(bundle_xml));

    /*
     * <publish node="eu.siacs.conversations.axolotl.bundles:1394567069">
     *   <item>
     *     <bundle xmlns="eu.siacs.conversations.axolotl">
     *       <signedPreKeyPublic signedPreKeyId="0">
     *         BVR1y9qOhyZXjDyG3agwNVZ9cAAa0EkkvtHIAec5ggBB
     *       </signedPreKeyPublic>
     *       <signedPreKeySignature>
     *         j//Z4tVTpC1xCb4guO+ADio7aaR3Vay2jL2FVZnry6yA2Rn8o9R6yyOq8W7/cKqiJMXDqyNS2AdKJ2Aho2uSjA==
     *       </signedPreKeySignature>
     *       <identityKey>
     *         BUFpuM6vO4PXetzYWojojqJ/zTmmtJXm8CGery99gKIO
     *       </identityKey>
     *       <prekeys>
     *         <preKeyPublic preKeyId="1">
     *           BZsyrh4JjrtfqI8wNQNtLtZeKD05nS72lEDKc03Hwbxw
     *         </preKeyPublic>
     *         <preKeyPublic preKeyId="2">
     *           Bb6l5Eyw+syqnqtfCd/bqtMOdqgLshhagV5McHDHbusB
     *         </preKeyPublic>
     *         <preKeyPublic preKeyId="3">
     *           BZUEqj4SznQw5RUsRYqBiGXdJjqtHymHu9eMyIV9bcwF
     *         </preKeyPublic>
     *         ...
     */

    purple_debug_info("lurch", "%s: published own bundle for %s\n", __func__, uname);

cleanup:
    if (err_msg_dbg) {
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
    }

    axc_context_destroy_all(axc_ctx_p);
    axc_bundle_destroy(axcbundle_p);
    omemo_bundle_destroy(omemobundle_p);
    free(bundle_xml);

    return ret_val;
}

/**
 * Processes a devicelist by updating the database with it.
 *
 * @param uname The username.
 * @param dl_in_p Pointer to the incoming devicelist.
 * @param js_p Pointer to the JabberStream.
 * @return 0 on success, negative on error.
 */
int Omemo::lurch_devicelist_process(char * uname, omemo_devicelist * dl_in_p /*, JabberStream * js_p*/) {
    int ret_val = 0;
    char * err_msg_dbg = nullptr;

    const char * from = nullptr;
    char * db_fn_omemo = nullptr;
    axc_context * axc_ctx_p = nullptr;
    omemo_devicelist * dl_db_p = nullptr;
    GList * add_l_p = nullptr;
    GList * del_l_p = nullptr;
    GList * curr_p = nullptr;
    uint32_t curr_id = 0;
    char * bundle_node_name = nullptr;

    char * temp;

    from = omemo_devicelist_get_owner(dl_in_p);
    db_fn_omemo = lurch_uname_get_db_fn(uname, LURCH_DB_NAME_OMEMO);

    purple_debug_info("lurch", "%s: processing devicelist from %s for %s\n", __func__, from, uname);

    ret_val = omemo_storage_user_devicelist_retrieve(from, db_fn_omemo, &dl_db_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to retrieve cached devicelist for %s from db %s", from, db_fn_omemo);
        goto cleanup;
    }

    omemo_devicelist_export(dl_db_p, &temp);
    purple_debug_info("lurch", "%s: %s\n%s\n", __func__, "cached devicelist is", temp);

    ret_val = omemo_devicelist_diff(dl_in_p, dl_db_p, &add_l_p, &del_l_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to diff devicelists");
        goto cleanup;
    }

    for (curr_p = add_l_p; curr_p; curr_p = curr_p->next) {
        curr_id = omemo_devicelist_list_data(curr_p);
        purple_debug_info("lurch", "%s: saving %i for %s to db %s\n", __func__, curr_id, from, db_fn_omemo);
        ret_val = omemo_storage_user_device_id_save(from, curr_id, db_fn_omemo);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to save %i for %s to %s", curr_id, from, db_fn_omemo);
            goto cleanup;
        }
    }

    ret_val = lurch_axc_get_init_ctx(uname, &axc_ctx_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to init axc ctx");
        goto cleanup;
    }

    for (curr_p = del_l_p; curr_p; curr_p = curr_p->next) {
        curr_id = omemo_devicelist_list_data(curr_p);
        purple_debug_info("lurch", "%s: deleting %i for %s to db %s\n", __func__, curr_id, from, db_fn_omemo);

        ret_val = omemo_storage_user_device_id_delete(from, curr_id, db_fn_omemo);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to delete %i for %s from %s", curr_id, from, db_fn_omemo);
            goto cleanup;
        }
    }

cleanup:
    if (err_msg_dbg) {
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
    }
    free(db_fn_omemo);
    omemo_devicelist_destroy(dl_db_p);
    axc_context_destroy_all(axc_ctx_p);
    g_list_free_full(add_l_p, free);
    g_list_free_full(del_l_p, free);
    free(bundle_node_name);
    free(temp);

    return ret_val;
}

/**
 * Set as callback for the "sending xmlnode" signal.
 * Encrypts the message body, if applicable.
 */
/*PurpleConnection * gc_p, xmlnode ** msg_stanza_pp*/
void Omemo::lurch_message_encrypt_im(const QString& receiver, const QString& message) {
    int ret_val = 0;
    char * err_msg_dbg = nullptr;
    int len = 0;

    //PurpleAccount * acc_p = nullptr;
    char * uname = nullptr;
    char * db_fn_omemo = nullptr;
    const char * to = nullptr;
    omemo_devicelist * dl_p = nullptr;
    GList * recipient_dl_p = nullptr;
    omemo_devicelist * user_dl_p = nullptr;
    GList * own_dl_p = nullptr;
    axc_context * axc_ctx_p = nullptr;
    uint32_t own_id = 0;
    omemo_message * msg_p = nullptr;
    GList * addr_l_p = nullptr;
    char * recipient = nullptr;
    char * tempxml = nullptr;
    char* xml_node_msg = nullptr;

    //recipient = jabber_get_bare_jid(xmlnode_get_attrib(*msg_stanza_pp, "to"));
    QByteArray recipientBuffer = receiver.toLocal8Bit();
    recipient = recipientBuffer.data();

    //acc_p = purple_connection_get_account(gc_p);
    //uname = lurch_uname_strip(purple_account_get_username(acc_p));
    std::string bareJid = client_->getJID().toBare().toString();
    QByteArray JidArray = QString::fromStdString(bareJid).toLocal8Bit();
    uname = JidArray.data();

    db_fn_omemo = lurch_uname_get_db_fn(uname, LURCH_DB_NAME_OMEMO);

    ret_val = omemo_storage_chatlist_exists(recipient, db_fn_omemo);
    if (ret_val < 0) {
        err_msg_dbg = g_strdup_printf("failed to look up %s in DB %s", recipient, db_fn_omemo);
        goto cleanup;
    } else if (ret_val == 1) {
        purple_debug_info("lurch", "%s: %s is on blacklist, skipping encryption\n", __func__, recipient);
        goto cleanup;
    }

    ret_val = lurch_axc_get_init_ctx(uname, &axc_ctx_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to get axc ctx for %s", uname);
        goto cleanup;
    }

    ret_val = axc_get_device_id(axc_ctx_p, &own_id);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to get device id");
        goto cleanup;
    }
    //tempxml = xmlnode_to_str(*msg_stanza_pp, &len);
    tempxml = "<message from='schorsch@jabber.ccc.de' to='schorsch@jabber-germany.de' id='ljlksdf9234lf09vxclv'><body>encrypted omemo message</body></message>"; //FIXME

    ret_val = omemo_message_prepare_encryption(tempxml, own_id, &crypto_, OMEMO_STRIP_ALL, &msg_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to construct omemo message");
        goto cleanup;
    }

    to = omemo_message_get_recipient_name_bare(msg_p);

    // determine if recipient is omemo user
    ret_val = omemo_storage_user_devicelist_retrieve(to, db_fn_omemo, &dl_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to retrieve devicelist for %s", to);
        goto cleanup;
    }

    //free(tempxml);

    // FIXME need valid pointer to pass in!!!
    ret_val = omemo_devicelist_export(dl_p, &tempxml);
    if(ret_val) {
        err_msg_dbg = g_strdup_printf("failed to export devicelist for %s", to);
        goto cleanup;
    }
    purple_debug_info("lurch", "retrieved devicelist for %s:\n%s\n", to, tempxml);

    recipient_dl_p = omemo_devicelist_get_id_list(dl_p);
    if (!recipient_dl_p) {
        ret_val = axc_session_exists_any(to, axc_ctx_p);
        if (ret_val < 0) {
            err_msg_dbg = g_strdup_printf("failed to check if session exists for %s in %s's db\n", to, uname);
            goto cleanup;
        } else if (ret_val == 1) {
            //purple_conv_present_error(recipient, purple_connection_get_account(gc_p), "Even though an encrypted session exists, the recipient's devicelist is empty."
            //                                                                          "The user probably uninstalled OMEMO, so you can add this conversation to the blacklist.");
            // FIXME
            std::cout << "Even though an encrypted session exists, the recipient's devicelist is empty.";
        } else {
            goto cleanup;
        }
    }

    ret_val = omemo_storage_user_devicelist_retrieve(uname, db_fn_omemo, &user_dl_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to retrieve devicelist for %s", uname);
        goto cleanup;
    }
    omemo_devicelist_export(user_dl_p, &tempxml);
    purple_debug_info("lurch", "retrieved own devicelist:\n%s\n", tempxml);
    own_dl_p = omemo_devicelist_get_id_list(user_dl_p);
    if (!own_dl_p) {
        err_msg_dbg = g_strdup_printf("no own devicelist");
        goto cleanup;
    }

    addr_l_p = lurch_addr_list_add(addr_l_p, user_dl_p, &own_id);
    addr_l_p = lurch_addr_list_add(addr_l_p, dl_p, nullptr);
    if (!addr_l_p) {
        err_msg_dbg = g_strdup_printf("failed to malloc address struct");
        ret_val = LURCH_ERR_NOMEM;
        goto cleanup;
    }

    ret_val = lurch_msg_finalize_encryption(axc_ctx_p, msg_p, addr_l_p, &xml_node_msg);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to finalize omemo message");
        goto cleanup;
    }

cleanup:
    if (err_msg_dbg) {
        // FIXME
        //purple_conv_present_error(recipient, purple_connection_get_account(gc_p), LURCH_ERR_STRING_ENCRYPT);
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
        //*msg_stanza_pp = (void *) 0;
    }
    if (ret_val) {
        omemo_message_destroy(msg_p);
        g_list_free_full(addr_l_p, lurch_addr_list_destroy_func);
    }
    //free(recipient);
    //free(uname);
    free(db_fn_omemo);
    omemo_devicelist_destroy(dl_p);
    g_list_free_full(recipient_dl_p, free);
    omemo_devicelist_destroy(user_dl_p);
    g_list_free_full(own_dl_p, free);
    axc_context_destroy_all(axc_ctx_p);
    //free(tempxml);
}

void Omemo::lurch_addr_list_destroy_func(gpointer data) {
  lurch_addr * addr_p = (lurch_addr *) data;
  free(addr_p->jid);
  free(addr_p);
}

/**
 * Does the final steps of encrypting the message.
 * If all devices have sessions, does the actual encrypting.
 * If not, saves it and sends bundle request to the missing devices so that the message can be sent at a later time.
 *
 * Note that if msg_stanza_pp points to NULL, both om_msg_p and addr_l_p must not be freed by the calling function.
 *
 * @param js_p          Pointer to the JabberStream to use.
 * @param axc_ctx_p     Pointer to the axc_context to use.
 * @param om_msg_p      Pointer to the omemo message.
 * @param addr_l_p      Pointer to a GList of lurch_addr structs that are supposed to receive the message.
 * @param msg_stanza_pp Pointer to the pointer to the <message> stanza.
 *                      Is either changed to point to the encrypted message, or to NULL if the message is to be sent later.
 * @return 0 on success, negative on error.
 *
 */
/*JabberStream * js_p,*/
int Omemo::lurch_msg_finalize_encryption(axc_context * axc_ctx_p, omemo_message * om_msg_p, GList * addr_l_p, char ** msg_stanza_pp) {
    int ret_val = 0;
    char * err_msg_dbg = nullptr;

    GList * no_sess_l_p = nullptr;
    char * xml = nullptr;
    //xmlnode * temp_node_p = nullptr;
    lurch_queued_msg * qmsg_p = nullptr;
    GList * curr_item_p = nullptr;
    lurch_addr curr_addr = {0};
    char * bundle_node_name = nullptr;

    ret_val = lurch_axc_sessions_exist(addr_l_p, axc_ctx_p, &no_sess_l_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to check if sessions exist");
        goto cleanup;
    }

    if (!no_sess_l_p) {
        ret_val = lurch_msg_encrypt_for_addrs(om_msg_p, addr_l_p, axc_ctx_p);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to encrypt symmetric key for addrs");
            goto cleanup;
        }

        ret_val = omemo_message_export_encrypted(om_msg_p, OMEMO_ADD_MSG_EME, &xml);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to export omemo msg to xml");
            goto cleanup;
        }

        //temp_node_p = xmlnode_from_str(xml, -1);
        //*msg_stanza_pp = temp_node_p;
        *msg_stanza_pp = xml;

        qDebug() << "#######ENC#####" << xml;

    } else {
        ret_val = lurch_queued_msg_create(om_msg_p, addr_l_p, no_sess_l_p, &qmsg_p);
        if (ret_val) {
            err_msg_dbg = g_strdup_printf("failed to create queued message");
            goto cleanup;
        }

        for (curr_item_p = no_sess_l_p; curr_item_p; curr_item_p = curr_item_p->next) {
            curr_addr.jid = ((lurch_addr *)curr_item_p->data)->jid;
            curr_addr.device_id = ((lurch_addr *)curr_item_p->data)->device_id;

            purple_debug_info("lurch", "%s: %s has device without session %i, requesting bundle\n", __func__, curr_addr.jid, curr_addr.device_id);

            ret_val = omemo_bundle_get_pep_node_name(curr_addr.device_id, &bundle_node_name);
            if (ret_val) {
                err_msg_dbg = g_strdup_printf("failed to get pep node name");
                goto cleanup;
            }

            lurch_bundle_request_do(curr_addr.jid,
                                    curr_addr.device_id,
                                    qmsg_p);

        }
        //*msg_stanza_pp = (void *) 0;
    }

cleanup:
    if (err_msg_dbg) {
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
        *msg_stanza_pp = nullptr;
    }
    if (!qmsg_p || ret_val) {
        free(qmsg_p);
    }

    free(xml);
    free(bundle_node_name);

    return ret_val;
}


/**
 * Requests a bundle.
 *
 * @param js_p Pointer to the JabberStream to use.
 * @param to The recipient of this request.
 * @param device_id The ID of the device whose bundle is needed.
 * @param qmsg_p Pointer to the queued message waiting on (at least) this bundle.
 * @return 0 on success, negative on error.
 */
int Omemo::lurch_bundle_request_do(const char * to,
                                   uint32_t device_id,
                                   lurch_queued_msg * qmsg_p) {

    /*
     * <iq type='get' from='romeo@montague.lit' to='juliet@capulet.lit' id='fetch1'>
          <pubsub xmlns='http://jabber.org/protocol/pubsub'>
            <items node='eu.siacs.conversations.axolotl.bundles:31415 max_items='1'/>
          </pubsub>
       </iq>
     */

#if 0
    int ret_val = 0;

    JabberIq * jiq_p = nullptr;
    xmlnode * pubsub_node_p = nullptr;
    char * device_id_str = nullptr;
    char * rand_str = nullptr;
    char * req_id = nullptr;
    char * bundle_node_name = nullptr;
    xmlnode * items_node_p = nullptr;

    purple_debug_info("lurch", "%s: %s is requesting bundle from %s:%i\n", __func__,
                      purple_account_get_username(purple_connection_get_account(js_p->gc)), to, device_id);

    jiq_p = jabber_iq_new(js_p, JABBER_IQ_GET);
    xmlnode_set_attrib(jiq_p->node, "to", to);

    pubsub_node_p = xmlnode_new_child(jiq_p->node, "pubsub");
    xmlnode_set_namespace(pubsub_node_p, "http://jabber.org/protocol/pubsub");

    device_id_str = g_strdup_printf("%i", device_id);
    rand_str = g_strdup_printf("%i", g_random_int());
    req_id = g_strconcat(to, "#", device_id_str, "#", rand_str, NULL);

    ret_val = omemo_bundle_get_pep_node_name(device_id, &bundle_node_name);
    if (ret_val) {
        purple_debug_error("lurch", "%s: failed to get bundle pep node name for %s:%i\n", __func__, to, device_id);
        goto cleanup;
    }

    items_node_p = xmlnode_new_child(pubsub_node_p, "items");
    xmlnode_set_attrib(items_node_p, "node", bundle_node_name);
    xmlnode_set_attrib(items_node_p, "max_items", "1");

    jabber_iq_set_id(jiq_p, req_id);
    jabber_iq_set_callback(jiq_p, lurch_bundle_request_cb, qmsg_p);

    jabber_iq_send(jiq_p);

    purple_debug_info("lurch", "%s: ...request sent\n", __func__);

cleanup:
    g_free(device_id_str);
    g_free(rand_str);
    g_free(req_id);
    g_free(bundle_node_name);

    return ret_val;
#endif

    // FIXME how to connect the pointer to the waiting message with the connected method of incoming bundles
    requestBundle(device_id, Swift::JID(to));
}


/**
 * Creates a queued msg.
 * Note that it just saves the pointers, so make sure they are not freed during
 * the lifetime of this struct and instead use the destroy function when done.
 *
 * @param om_msg_p Pointer to the omemo_message.
 * @param recipient_addr_l_p Pointer to the list of recipient addresses.
 * @param no_sess_l_p Pointer to the list that contains the addresses that do
 *                    not have sessions, i.e. for which bundles were requested.
 * @param cmsg_pp Will point to the pointer of the created queued msg struct.
 * @return 0 on success, negative on error.
 */
int Omemo::lurch_queued_msg_create(omemo_message * om_msg_p,
                                   GList * recipient_addr_l_p,
                                   GList * no_sess_l_p,
                                   lurch_queued_msg ** qmsg_pp) {
    int ret_val = 0;
    char * err_msg_dbg = nullptr;

    lurch_queued_msg * qmsg_p = nullptr;
    GHashTable * sess_handled_p = nullptr;

    qmsg_p = (lurch_queued_msg *)malloc(sizeof(lurch_queued_msg));
    if (!qmsg_p) {
        ret_val = LURCH_ERR_NOMEM;
        err_msg_dbg = g_strdup_printf("failed to malloc space for queued msg struct");
        goto cleanup;
    }

    sess_handled_p = g_hash_table_new(g_str_hash, g_str_equal);

    qmsg_p->om_msg_p = om_msg_p;
    qmsg_p->recipient_addr_l_p = recipient_addr_l_p;
    qmsg_p->no_sess_l_p = no_sess_l_p;
    qmsg_p->sess_handled_p = sess_handled_p;

    *qmsg_pp = qmsg_p;

cleanup:
    if (ret_val) {
        free(qmsg_p);
    }
    if (err_msg_dbg) {
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
    }
    return ret_val;
}



/**
 * For each of the recipients, encrypts the symmetric key using the existing axc session,
 * then adds it to the omemo message.
 * If the session does not exist, the recipient is skipped.
 *
 * @param om_msg_p Pointer to the omemo message.
 * @param addr_l_p Pointer to the head of a list of the intended recipients' lurch_addrs.
 * @param axc_ctx_p Pointer to the axc_context to use.
 * @return 0 on success, negative on error.
 */
int Omemo::lurch_msg_encrypt_for_addrs(omemo_message * om_msg_p, GList * addr_l_p, axc_context * axc_ctx_p) {
    int ret_val = 0;
    char * err_msg_dbg = nullptr;

    GList * curr_l_p = nullptr;
    lurch_addr * curr_addr_p = nullptr;
    axc_address addr = {0};
    axc_buf * curr_key_ct_buf_p = nullptr;

    purple_debug_info("lurch", "%s: trying to encrypt key for %i devices\n", __func__, g_list_length(addr_l_p));

    for (curr_l_p = addr_l_p; curr_l_p; curr_l_p = curr_l_p->next) {
        curr_addr_p = (lurch_addr *) curr_l_p->data;
        addr.name = curr_addr_p->jid;
        addr.name_len = strnlen(addr.name, JABBER_MAX_LEN_BARE);
        addr.device_id = curr_addr_p->device_id;

        ret_val = axc_session_exists_initiated(&addr, axc_ctx_p);
        if (ret_val < 0) {
            err_msg_dbg = g_strdup_printf("failed to check if session exists, aborting");
            goto cleanup;
        } else if (!ret_val) {
            continue;
        } else {
            ret_val = lurch_key_encrypt(curr_addr_p,
                                        omemo_message_get_key(om_msg_p),
                                        omemo_message_get_key_len(om_msg_p),
                                        axc_ctx_p,
                                        &curr_key_ct_buf_p);
            if (ret_val) {
                err_msg_dbg = g_strdup_printf("failed to encrypt key for %s:%i", curr_addr_p->jid, curr_addr_p->device_id);
                goto cleanup;
            }

            ret_val = omemo_message_add_recipient(om_msg_p,
                                                  curr_addr_p->device_id,
                                                  axc_buf_get_data(curr_key_ct_buf_p),
                                                  axc_buf_get_len(curr_key_ct_buf_p));
            if (ret_val) {
                err_msg_dbg = g_strdup_printf("failed to add recipient to omemo msg");
                goto cleanup;
            }

            axc_buf_free(curr_key_ct_buf_p);
            curr_key_ct_buf_p = nullptr;
        }
    }

cleanup:
    if (err_msg_dbg) {
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
    }
    axc_buf_free(curr_key_ct_buf_p);

    return ret_val;
}

/**
 * Encrypts a data buffer, usually the omemo symmetric key, using axolotl.
 * Assumes a valid session already exists.
 *
 * @param recipient_addr_p Pointer to the lurch_addr of the recipient.
 * @param key_p Pointer to the key data.
 * @param key_len Length of the key data.
 * @param axc_ctx_p Pointer to the axc_context to use.
 * @param key_ct_pp Will point to a pointer to an axc_buf containing the key ciphertext on success.
 * @return 0 on success, negative on error
 */
int Omemo::lurch_key_encrypt(const lurch_addr * recipient_addr_p,
                             const uint8_t * key_p,
                             size_t key_len,
                             axc_context * axc_ctx_p,
                             axc_buf ** key_ct_buf_pp) {
    int ret_val = 0;
    char * err_msg_dbg = nullptr;

    axc_buf * key_buf_p = nullptr;
    axc_buf * key_ct_buf_p = nullptr;
    axc_address axc_addr = {0};

    purple_debug_info("lurch", "%s: encrypting key for %s:%i\n", __func__, recipient_addr_p->jid, recipient_addr_p->device_id);

    key_buf_p = axc_buf_create(key_p, key_len);
    if (!key_buf_p) {
        err_msg_dbg = g_strdup_printf("failed to create buffer for the key");
        goto cleanup;
    }

    axc_addr.name = recipient_addr_p->jid;
    axc_addr.name_len = strnlen(axc_addr.name, JABBER_MAX_LEN_BARE);
    axc_addr.device_id = recipient_addr_p->device_id;

    ret_val = axc_message_encrypt_and_serialize(key_buf_p, &axc_addr, axc_ctx_p, &key_ct_buf_p);
    if (ret_val) {
        err_msg_dbg = g_strdup_printf("failed to encrypt the key");
        goto cleanup;
    }

    *key_ct_buf_pp = key_ct_buf_p;

cleanup:
    if (ret_val) {
        axc_buf_free(key_ct_buf_p);
    }
    if (err_msg_dbg) {
        purple_debug_error("lurch", "%s: %s (%i)\n", __func__, err_msg_dbg, ret_val);
        free(err_msg_dbg);
    }
    axc_buf_free(key_buf_p);

    return ret_val;
}


/**
 * For a list of lurch_addrs, checks which ones do not have an active session.
 * Note that the structs are not copied, the returned list is just a subset
 * of the pointers of the input list.
 *
 * @param addr_l_p A list of pointers to lurch_addr structs.
 * @param axc_ctx_p The axc_context to use.
 * @param no_sess_l_pp Will point to a list that contains pointers to those
 *                     addresses that do not have a session.
 * @return 0 on success, negative on error.
 */
int Omemo::lurch_axc_sessions_exist(GList * addr_l_p, axc_context * axc_ctx_p, GList ** no_sess_l_pp){
    int ret_val = 0;

    GList * no_sess_l_p = nullptr;

    GList * curr_p;
    lurch_addr * curr_addr_p;
    axc_address curr_axc_addr = {0};
    for (curr_p = addr_l_p; curr_p; curr_p = curr_p->next) {
        curr_addr_p = (lurch_addr *) curr_p->data;

        curr_axc_addr.name = curr_addr_p->jid;
        curr_axc_addr.name_len = strnlen(curr_axc_addr.name, JABBER_MAX_LEN_BARE);
        curr_axc_addr.device_id = curr_addr_p->device_id;

        ret_val = axc_session_exists_initiated(&curr_axc_addr, axc_ctx_p);
        if (ret_val < 0) {
            purple_debug_error("lurch", "%s: %s (%i)\n", __func__, "failed to see if session exists", ret_val);
            goto cleanup;
        } else if (ret_val > 0) {
            ret_val = 0;
            continue;
        } else {
            no_sess_l_p = g_list_prepend(no_sess_l_p, curr_addr_p);
            ret_val = 0;
        }
    }

    *no_sess_l_pp = no_sess_l_p;

cleanup:
    return ret_val;
}


/**
 * Adds an omemo devicelist to a GList of lurch_addrs.
 *
 * @param addrs_p Pointer to the list to add to. Remember NULL is a valid GList *.
 * @param dl_p Pointer to the omemo devicelist to add.
 * @param exclude_id_p Pointer to an ID that is not to be added. Useful when adding the own devicelist. Can be NULL.
 * @return Pointer to the updated GList on success, NULL on error.
 */
GList* Omemo::lurch_addr_list_add(GList * addrs_p, const omemo_devicelist * dl_p, const uint32_t * exclude_id_p) {
    int ret_val = 0;

    GList * new_l_p = addrs_p;
    GList * dl_l_p = nullptr;
    GList * curr_p = nullptr;
    lurch_addr curr_addr = {0};
    uint32_t curr_id = 0;
    lurch_addr * temp_addr_p = nullptr;

    curr_addr.jid = g_strdup(omemo_devicelist_get_owner(dl_p));

    dl_l_p = omemo_devicelist_get_id_list(dl_p);

    for (curr_p = dl_l_p; curr_p; curr_p = curr_p->next) {
        curr_id = omemo_devicelist_list_data(curr_p);
        if (exclude_id_p && *exclude_id_p == curr_id) {
            continue;
        }

        curr_addr.device_id = curr_id;

        temp_addr_p = (lurch_addr *)malloc(sizeof(lurch_addr));
        if (!temp_addr_p) {
            ret_val = LURCH_ERR_NOMEM;
            goto cleanup;
        }

        memcpy(temp_addr_p, &curr_addr, sizeof(lurch_addr));

        new_l_p = g_list_prepend(new_l_p, temp_addr_p);
    }

cleanup:
    g_list_free_full(dl_l_p, free);

    if (ret_val) {
        g_list_free_full(new_l_p, lurch_addr_list_destroy_func);
        return nullptr;
    } else {
        return new_l_p;
    }
}



/*
 * Strips the <pubsub ..> root element and returns the xml starting with next node, which must be a
 *              <itmes ..> tag
 */
QString Omemo::getItemsChildFromPubSubXml(const QString &xml)
{
    QString returnXml = "";

    QDomDocument d;
    d.setContent(xml);

    QDomElement element = d.documentElement();
    QDomNode n = element.firstChildElement("items");
    if (! n.isNull())
    {
        QDomDocument dd("");
        dd.appendChild(n);
        returnXml = dd.toString(-1);
    }

    return returnXml;
}

bool Omemo::isEncryptedMessage(const QString& xmlNode)
{
    bool returnValue = false;

    QDomDocument d;
    if (d.setContent(xmlNode) == true)
    {
        QDomNodeList nodeList = d.elementsByTagName("message");
        if (!nodeList.isEmpty())
        {
            //qDebug() << "found msg";
            QDomNodeList encList = d.elementsByTagName("encrypted");
            if (!encList.isEmpty())
            {
                //qDebug() << "found enc";
                returnValue = true;
            }
        }
    }

    return returnValue;
}

QString Omemo::getValueForElementInMessage(const QString& xmlNode, const QString& elementString)
{
    QString returnValue = "";

    QDomDocument d;
    if (d.setContent(xmlNode) == true)
    {
        QDomNodeList nodeList1 = d.elementsByTagName("message");
        if (!nodeList1.isEmpty())
        {
            QDomElement element = nodeList1.at(0).toElement();
            QDomNode toNode = element.attributeNode(elementString);

            returnValue = toNode.nodeValue();
        }
    }

    return returnValue;
}

/*
 * Mock mock.
 * Catch purple debug messages
 */
void Omemo::purple_debug_info(const char *category, const char *format,...)
{
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
}

void Omemo::purple_debug_error(const char *category, const char *format,...)
{
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
}

